import { Project } from "ts-morph";
import z from "zod";

export const OpenAPISpec = z.object({
  openapi: z.string(),
  info: z.object({
    title: z.string(),
    version: z.string(),
  }),
  paths: z.record(
    z.record(
      z.object({
        summary: z.string().optional(),
        operationId: z.string(),
        parameters: z
          .array(
            z.object({
              name: z.string(),
              in: z.string(),
              required: z.boolean(),
              schema: z.object({
                type: z.string(),
              }),
            })
          )
          .optional(),
        responses: z.record(
          z.object({
            description: z.string().optional(),
            content: z.record(
              z.object({
                schema: z.object({
                  type: z.string(),
                  properties: z.record(
                    z.object({
                      type: z.string(),
                    })
                  ),
                }),
              })
            ),
          })
        ),
      })
    )
  ),
});

export function gen(spec: z.infer<typeof OpenAPISpec>, outdir: string) {
  const formatOptions = {
    indentMultiLineObjectLiteralBeginningOnBlankLine: true,
    ensureNewLineAtEndOfFile: true,
    indentSize: 2,
  };
  const project = new Project();

  const typesFile = project.createSourceFile(
    `${outdir}/types.ts`,
    (writer) => {
      writer.writeLine(`// This file is auto-generated by <your tool name>.
        // Changes to this file may be overwritten.`);

      writer.blankLine();

      writer.writeLine(`import z from "zod";`);

      writer.blankLine();

      // parameters
      for (const [path, methods] of Object.entries(spec.paths)) {
        for (const [_method, { operationId, parameters }] of Object.entries(
          methods
        )) {
          writer.writeLine(
            `export const ${operationId}_Parameters = z.object({`
          );

          parameters?.forEach((param) => {
            // TODO: Recursively build up the parameter types from  param.schema
            writer.writeLine(`${param.name}: z.coerce.string(),`);
          });
        }

        writer.writeLine("});");
        writer.blankLine();

        // responses
        for (const [_method, { operationId, responses }] of Object.entries(
          methods
        )) {
          for (const [status, { content }] of Object.entries(responses)) {
            for (const [contentType, { schema }] of Object.entries(content)) {
              writer.writeLine(
                `export const ${operationId}_ResponseBody = z.object({`
              );

              writer.writeLine(`status: z.literal("${status}"),`);
              writer.writeLine(`content: z.record(z.object({`);

              for (const [prop, { type }] of Object.entries(
                schema.properties
              )) {
                // TODO: Recursively build up the parameter types from  param.schema
                writer.writeLine(`${prop}: z.coerce.${type}(),`);
              }

              writer.writeLine("})),");
              writer.writeLine("});");
            }
          }
        }
      }
    },
    { overwrite: true }
  );
  typesFile.formatText(formatOptions);
  typesFile.saveSync();

  const serverFile = project.createSourceFile(
    `${outdir}/server.ts`,
    (writer) => {
      writer.writeLine(`// This file is auto-generated by <your tool name>.
        // Changes to this file may be overwritten.`);

      writer.blankLine();

      writer.writeLine(`import z from "zod";`);
      writer.writeLine('import * as types from "./types";');

      writer.blankLine();

      // Service interface
      for (const [path, methods] of Object.entries(spec.paths)) {
        writer.writeLine("export interface APIService {");

        for (const [_method, { operationId }] of Object.entries(methods)) {
          writer.writeLine(
            `${operationId}: (params: z.infer<typeof types.${operationId}_Parameters>) => Promise<z.infer<typeof types.${operationId}_ResponseBody>>;`
          );
        }

        writer.writeLine("}");

        writer.blankLine();
      }

      // registerService
      writer.writeLine(
        `export function registerService(service: APIService) {`
      );
      writer.writeLine("return [");
      for (const [path, methods] of Object.entries(spec.paths)) {
        for (const [method, { operationId }] of Object.entries(methods)) {
          writer.writeLine("{");
          writer.writeLine(`path: "${path}",`);
          writer.writeLine(`method: "${method}" as const,`);
          writer.writeLine(`paramType: types.${operationId}_Parameters,`);
          writer.writeLine(`responseType: types.${operationId}_ResponseBody,`);
          writer.writeLine(`handler: service.${operationId},`);
          writer.writeLine("},");
        }
        writer.writeLine("];");
        writer.writeLine("}");
      }
    },
    { overwrite: true }
  );
  serverFile.formatText(formatOptions);
  serverFile.saveSync();
}
